@using patter_pal.Util;
@using patter_pal.Models;
@{
    ViewData["Title"] = "Home Page";
}

<div class="row vh-100-no-footer align-items-start align-items-md-center justify-content-center g-4">
    <!-- Toggle button for the left column -->
    <button class="btn btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#leftMenu" aria-expanded="false" aria-controls="leftMenu">
        Toggle Menu todo
    </button>

    <!-- Left column for list menu -->
    <div class="col-lg-3 collapse show overflow-auto" id="leftMenu">
        <div class="list-group">
            <a href="#" class="list-group-item list-group-item-action active">bla bla bla - en-US</a>
            <a href="#" class="list-group-item list-group-item-action">bla bla bla - en-US</a>
            <a href="#" class="list-group-item list-group-item-action">bla bla bla - en-US</a>
        </div>
    </div>

    <!-- Middle column for microphone, language selector, and state label -->
    <div class="col-12 col-md-6 col-lg-3 text-center">
        <button id="micButton" type="submit" class="display-1 btn btn-outline-light rounded-circle border-4">
            <span>🎙</span>
        </button>
        <div id="languageSelectContainer" class="pt-3 fade-in">
            <select class="form-select form-select-sm text-center" id="languageSelect">
                @foreach (var language in LanguageConstants.Languages)
                {
                    <option value="@language.Key" selected="@(language.Key==LanguageConstants.DefaultLanguage)">@language.Value</option>
                }
            </select>
        </div>
        <p id="stateLabel" class="text-muted text-center">Ready to connect...</p>
    </div>

    <!-- Right column for text bubbles -->
    <div class="col-lg-4 justify-content-center overflow-auto">
        <div class="d-flex align-items-center mb-3">
            <span class="speaker-img left">😁</span>
            <div class="bg-light rounded-5 ms-2 p-2">
                <p id="textOutput" class="mb-0 text-break">
                    Aaaaa bbbb cccc 
                    Aaaaa bbbb cccc 
                    Aaaaa bbbb cccc 
                    Aaaaa bbbb cccc 
                </p>
            </div>
        </div>
        <div class="d-flex align-items-center justify-content-end">
            <div class="bg-primary text-white rounded-3 me-2 p-2">
                <p class="mb-0 text-break">Short answer like this</p>
            </div>
            <span class="speaker-img right">😀</span>
        </div>
    </div>
</div>

@section Scripts {
    <script type="module">
        import { resolveHostWebSocketURL, resolveHostURL, htmlEscape } from './js/helpers.js';
        import { fetchConversationAnswer } from './js/conversation_api.js';
        import { AudioRecognitionStreamer } from './js/audio_recognition.js';

        const micButton = document.getElementById('micButton');
        const stateLabel = document.getElementById('stateLabel');
        const languageSelect = document.getElementById('languageSelect');
        const languageSelectContainer = document.getElementById('languageSelectContainer');
        const textOutput = document.getElementById('textOutput'); // TODO template for text output

        // Enum for socket result types
        const SocketResultType = {
        @foreach (var enumName in Enum.GetNames(typeof(SocketResultType)))
        {
            @: "@enumName": @(Convert.ToInt32(Enum.Parse(typeof(SocketResultType), enumName))),
        }};

        let audioRecStreamer = null;
        let socket = null;

        function updateConversationUi() {
            const socketOpen = socket?.readyState == WebSocket.OPEN;
            const isRecording = audioRecStreamer && socketOpen;
            const isResponding = !audioRecStreamer && socketOpen;

            languageSelect.disabled = socketOpen;
            languageSelectContainer.classList.toggle('fade-out', socketOpen);

            micButton.classList.toggle('active', isRecording);
            micButton.disabled = isResponding; // Can cancel recording, but not start new one when server is responding

            console.log(`socketOpen: ${socketOpen}, isRecording: ${isRecording}, isResponding: ${isResponding}`);

            switch (socket?.readyState) {
                case WebSocket.CONNECTING:
                    stateLabel.innerHTML = "Starting...";
                    break;
                case WebSocket.OPEN:
                    stateLabel.innerHTML = "Speak now...";
                    break;
                default:
                    // Closing, Closed and not initialized
                    stateLabel.innerHTML = "Ready to start...";
                    break;
            }
        }

        function socketMessageHandler(message) {
            try {
                const result = JSON.parse(message.data);

                switch (result?.Type) {
                    case (SocketResultType.Error):
                        if (result.Data.Message) alert(result.Data.Message); // Todo handling
                        console.error(result.Data);
                        stopAudioStream(false);
                        destroySocket();
                        break;
                    case (SocketResultType.PartialSpeech):
                        textOutput.innerHTML = htmlEscape(result.Data);
                        break;
                    case (SocketResultType.SpeechResult):
                        stopAudioStream();
                        textOutput.innerHTML = htmlEscape(result.Data.Text);
                        break;
                    case (SocketResultType.PartialAnswer):
                        textOutput.innerHTML = htmlEscape(result.Data);
                        break;
                    case (SocketResultType.AnswerResult):
                        textOutput.innerHTML = htmlEscape(result.Data.Text);
                        destroySocket(); // Final result received, close socket
                        break;
                    default:
                        throw new Error(`Unknown socket result type: ${result.Type}`);
                }

                console.log(result);
            } catch (error) {
                console.warn(`Unhandelable socket message: ${message}`)
            }
        }

        function stopAudioStream(graceful = true) {
            if (!graceful) audioRecStreamer?.abortRecording();
            else audioRecStreamer?.stopRecording();

            audioRecStreamer = null;
            updateConversationUi();
        }

        function initSocket() {
            socket.onopen = async (event) => {
                // Start audio recording when the socket is ready
                try {
                    await audioRecStreamer.startRecording();
                } catch (error) {
                    alert(`This application requires your microphone permission. Please enable it in the top of your browser.\nIf it still does not work, you might have to update your browser or try a different one.`);
                    stopAudioStream(false);
                }
                updateConversationUi();
            };
            socket.onmessage = socketMessageHandler;
            socket.onclose = (event) => {
                console.log(`WebSocket closed ${event.reason}`);
                // Closed, no need to do graceful shutdown
                stopAudioStream(false);
            };
            socket.onerror = (event) => {
                console.error(`WebSocket error ${event.reason}`);
                stopAudioStream(false);
            };
        }

        function destroySocket() {
            socket?.close();
            socket = null;
        }

        // --- Event Handlers --- //

        micButton.onclick = () => {
            if (audioRecStreamer || socket?.readyState == WebSocket.OPEN) {
                stopAudioStream();
                return;
            }

            const connectionUrl = resolveHostWebSocketURL("@AppConfig.ConversationWebSocket" + "/" + languageSelect.value); // TODO optional guid existing chat
            socket = new WebSocket(connectionUrl);
            audioRecStreamer = new AudioRecognitionStreamer(socket, @AppConfig.RecordingBufferSize, @AppConfig.RecordingChunkTimeMs, @AppConfig.TargetSampleRate);
            initSocket();
        };
    </script>
}



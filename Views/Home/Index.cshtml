@using patter_pal.Util;
@using patter_pal.Models;
@{
    ViewData["Title"] = "Home Page";
}

<div class="vh-100-no-footer d-flex flex-column align-items-center justify-content-center">
    <div class="row">
        <button id="micButton" type="submit" class="display-1 btn btn-outline-light rounded-circle">🎙</button>
        <p id="textOutput" class="text-center"></p>
    </div>
    <div>
        <select class="form-select text-center" id="languageSelect">
            @foreach (var language in LanguageConstants.Languages)
            {
                <option value="@language.Key" selected="@(language.Key==LanguageConstants.DefaultLanguage)">@language.Value</option>
            }
        </select>
    </div>
    <p id="stateLabel" class="text-muted text-center">Ready to connect...</p>
</div>

@section Scripts {
    <script type="module">
        import { resolveHostWebSocketURL, resolveHostURL, htmlEscape } from './js/helpers.js';
        import { fetchConversationAnswer } from './js/conversation_api.js';
        import { AudioRecognitionStreamer } from './js/audio_recognition.js';

        const micButton = document.getElementById('micButton');
        const stateLabel = document.getElementById('stateLabel');
        const languageSelect = document.getElementById('languageSelect');
        const textOutput = document.getElementById('textOutput'); // TODO template for text output

        // Enum for socket result types
        const SocketResultType = {
            @foreach (var enumName in Enum.GetNames(typeof(SocketResultType)))
            {
                @: "@enumName": @(Convert.ToInt32(Enum.Parse(typeof(SocketResultType), enumName))),
            }
        };

        let audioRecStreamer = null;
        let socket = null;

        function updateConversationUi() {
            const socketOpen = socket?.readyState == WebSocket.OPEN;
            const isRecording = audioRecStreamer && socketOpen;
            const isResponding = !audioRecStreamer && socketOpen;

            languageSelect.disabled = socketOpen;
            micButton.disabled = isResponding; // Can cancel recording, but not start new one when server is responding

            console.log(`socketOpen: ${socketOpen}, isRecording: ${isRecording}, isResponding: ${isResponding}`);

            switch (socket?.readyState) {
                case WebSocket.CONNECTING:
                    stateLabel.innerHTML = "Starting...";
                    break;
                case WebSocket.OPEN:
                    stateLabel.innerHTML = "Speak now...";
                    break;
                default:
                    // Closing, Closed and not initialized
                    stateLabel.innerHTML = "Ready to start...";
                    break;
            }
        }

        function socketMessageHandler(message) {
            try {
                const result = JSON.parse(message.data);

                if (result.RecognitionStatus == 'Success') {
                    stopAudioStream();
                }

                switch(result?.Type){
                    case (SocketResultType.Error):
                        alert(result.Data); // Todo handling
                        stopAudioStream(false);
                        destroySocket();
                        break;
                    case (SocketResultType.PartialSpeech):
                        textOutput.innerHTML = htmlEscape(result.Data);
                        break;
                    case (SocketResultType.SpeechResult):
                        stopAudioStream();
                        textOutput.innerHTML = htmlEscape(result.Data.Text);
                        break;
                    case (SocketResultType.PartialAnswer):
                        textOutput.innerHTML = htmlEscape(result.Data);
                        break;
                    case (SocketResultType.AnswerResult):
                        textOutput.innerHTML = htmlEscape(result.Data.Text);
                        destroySocket(); // Final result received, close socket
                        break;
                    default:
                        throw new Error(`Unknown socket result type: ${result.Type}`);
                }

                console.log(result);
            } catch (error) {
                console.warn(`Unhandelable socket message: ${message}`)
            }
        }

        function stopAudioStream(graceful = true) {
            if (!graceful) audioRecStreamer?.abortRecording();
            else audioRecStreamer?.stopRecording();

            audioRecStreamer = null;
            updateConversationUi();
        }

        function initSocket() {
            socket.onopen = async (event) => {
                // Start audio recording when the socket is ready
                try {
                    await audioRecStreamer.startRecording();
                } catch (error) {
                    alert(`This application requires your microphone permission. Please enable it in the top of your browser.\nIf it still does not work, you might have to update your browser or try a different one.`);
                    stopAudioStream(false);
                }
                updateConversationUi();
            };
            socket.onmessage = socketMessageHandler;
            socket.onclose = (event) => {
                console.log(`WebSocket closed ${event.reason}`);
                // Closed, no need to do graceful shutdown
                stopAudioStream(false);
            };
            socket.onerror = (event) => {
                console.error(`WebSocket error ${event.reason}`);
                stopAudioStream(false);
            };
        }

        function destroySocket() {
            socket?.close();
            socket = null;
        }

        // --- Event Handlers --- //

        micButton.onclick = () => {
            if (audioRecStreamer || socket?.readyState == WebSocket.OPEN) {
                stopAudioStream();
                return;
            }

            const connectionUrl = resolveHostWebSocketURL("@AppConfig.ConversationWebSocket" + "/" + languageSelect.value); // TODO optional guid existing chat
            socket = new WebSocket(connectionUrl);
            audioRecStreamer = new AudioRecognitionStreamer(socket, @AppConfig.RecordingBufferSize, @AppConfig.RecordingChunkTimeMs, @AppConfig.TargetSampleRate);
            initSocket();
        };
    </script>
}



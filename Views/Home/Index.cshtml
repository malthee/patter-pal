@using patter_pal.Util;
@{
    ViewData["Title"] = "Home Page";
}

<!-- Websocket example code -->
<h1>WebSocket Sample Application</h1>
<p id="stateLabel">Ready to connect...</p>
<div>
    <label for="connectionUrl">WebSocket Server URL:</label>
    <input id="connectionUrl" />
    <button id="connectButton" type="submit">Connect</button>
</div>
<p></p>
<div>
    <button id="closeButton" disabled>Close Socket</button>
</div>

<h2>Communication Log</h2>
<table style="width: 800px">
    <thead>
        <tr>
            <td style="width: 100px">From</td>
            <td style="width: 100px">To</td>
            <td>Data</td>
        </tr>
    </thead>
    <tbody id="commsLog">
    </tbody>
</table>

<!-- https://medium.com/(AT)ragymorkos/gettineg-monochannel-16-bit-signed-integer-pcm-audio-samples-from-the-microphone-in-the-browser-8d4abf81164d
-->

<script>
    let audioContext;
    let processor;
    let socket; // Assume socket is already connected to your server
    let audioBuffer = [];

    async function startRecording() {
        try {
            // Initialize Audio Context and Processor
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            processor = audioContext.createScriptProcessor(4096*4, 1, 1); // Buffer size, input channels, output channels

            // Get audio stream from microphone
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(processor);
            processor.connect(audioContext.destination);

            processor.onaudioprocess = function (e) {
                const inputData = e.inputBuffer.getChannelData(0);
                const outputData = new Int16Array(inputData.length);

                // Convert to 16-bit PCM
                for (let i = 0; i < inputData.length; i++) {
                    outputData[i] = convertFloat32ToInt16(inputData[i]);
                }

                // Add to audio buffer
                audioBuffer.push(outputData);
            };

            // Set an interval to send audio data every few seconds
            setInterval(sendAudioData, 3000);
        } catch (error) {
            console.error('Error accessing media devices:', error);
        }
    }

    function sendAudioData() {
        if (socket.readyState === WebSocket.OPEN && audioBuffer.length > 0) {
            let concatenatedBuffer = concatenateBuffers(audioBuffer);
            socket.send(concatenatedBuffer);
            audioBuffer = []; // Clear the buffer after sending
        }
    }

    function concatenateBuffers(buffers) {
        let totalLength = buffers.reduce((acc, value) => acc + value.length, 0);
        let result = new Int16Array(totalLength);
        let offset = 0;

        for (let buffer of buffers) {
            result.set(buffer, offset);
            offset += buffer.length;
        }

        return result.buffer;
    }

    function convertFloat32ToInt16(buffer) {
        let l = buffer.length;
        let buf = new Int16Array(l);
        while (l--) {
            buf[l] = Math.min(1, buffer[l]) * 0x7FFF;
        }
        return buf.buffer;
    }

    function stopRecording() {
        if (processor && audioContext) {
            processor.disconnect();
            audioContext.close();
        }
        // Close WebSocket connection if needed
        socket?.close(3000, 'Client closed');
    }

    
    //function mergeBuffers(channelBuffer, recordingLength) {
    //    let result = new Float32Array(recordingLength);
    //    let offset = 0;

    //    for (let i = 0; i < channelBuffer.length; i++) {
    //        result.set(channelBuffer[i], offset);
    //        offset += channelBuffer[i].length;
    //    }

    //    return Array.prototype.slice.call(result);
    //}


    //function startRecording() {
    //    navigator.getUserMedia = navigator.getUserMedia ||
    //        navigator.webkitGetUserMedia ||
    //        navigator.mozGetUserMedia ||
    //        navigator.msGetUserMedia;

    //    let audioStream;

    //    if (navigator.getUserMedia) {
    //        navigator.getUserMedia({ audio: true }, function (stream) {
    //            audioStream = stream;
    //        }, function (error) {
    //            alert('Error capturing audio.');
    //        });
    //    }
    //    else {
    //        alert('getUserMedia not supported in this browser.');
    //    }

    //    // creates the an instance of audioContext
    //    const context = window.AudioContext || window.webkitAudioContext;
    //    const audioContext = new context();

    //    // retrieve the current sample rate of microphone the browser is using
    //    const sampleRate = audioContext.sampleRate;

    //    // creates a gain node
    //    const volume = audioContext.createGain();

    //    // creates an audio node from the microphone incoming stream
    //    const audioInput = audioContext.createMediaStreamSource(audioStream);

    //    // connect the stream to the gain node
    //    audioInput.connect(volume);

    //    /* From the spec: This value controls how frequently the audioprocess event is
    //    dispatched and how many sample-frames need to be processed each call.
    //    Lower values for buffer size will result in a lower (better) latency.
    //    Higher values will be necessary to avoid audio breakup and glitches */
    //    const bufferSize = 2048;
    //    const recorder = (audioContext.createScriptProcessor ||
    //        audioContext.createJavaScriptNode).call(audioContext,
    //            bufferSize,
    //            1,
    //            1);
    //    const leftChannel = [];
    //    let recordingLength = 0;

    //    recorder.onaudioprocess = function (event) {
    //        const samples = event.inputBuffer.getChannelData(0);

    //        // we clone the samples
    //        leftChannel.push(new Float32Array(samples));

    //        recordingLength += bufferSize;
    //    };

    //    // we connect the recorder
    //    volume.connect(recorder);

    //    // start recording
    //    recorder.connect(audioContext.destination);

    //    const PCM32fSamples = mergeBuffers(leftChannel, recordingLength);
    //    const PCM16iSamples = [];

    //    for (let i = 0; i < PCM32fSamples.length; i++) {
    //        let val = Math.floor(32767 * PCM32fSamples[i]);
    //        val = Math.min(32767, val);
    //        val = Math.max(-32768, val);

    //        PCM16iSamples.push(val);
    //    }
    //}

    //function stopRecording(){
    //    console.log('stopped rec');
    //    socket?.close(3000, 'Done');
    //    recorder.disconnect();
    //}

    //import audioConverter from './js/buffer_to_wav.js';
    //console.log(audioConverter);

    //let socket;
    //let mediaRecorder;
    //let audioChunks = [];

    //async function startRecording() {
    //    if (!socket) {
    //        console.error('NOT SETUP WARNING');
    //        return;
    //    }

    //    try {
    //        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    //        let stream = await navigator.mediaDevices.getUserMedia({ audio: true });

    //        let mediaRecorder = new MediaRecorder(stream, {
    //            mimeType: 'audio/webm',
    //            codecs: "opus",
    //        });
    //        mediaRecorder.start(@AppConfig.SpeechRecordTimesliceMs);
    //        //mediaRecorder.start(5000);

    //        mediaRecorder.ondataavailable = async (event) => {
    //            if (event.data.size <= 0) return; // Ignore empty data

    //            console.log('Data available:', event.data);

    //            try {
    //                let arrayBuffer = await readFileAsArrayBuffer(event.data);
    //                let audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

    //                let wav = audioConverter(audioBuffer);
    //                console.log('Converted:', wav);
    //                socket.send(wav);
    //            } catch (err) {
    //                console.error('Error processing audio data:', err);
    //            }
    //        };
    //    } catch (error) {
    //        console.error('Error accessing media devices:', error);
    //    }
    //}

    //function readFileAsArrayBuffer(blob) {
    //    return new Promise((resolve, reject) => {
    //        let reader = new FileReader();
    //        reader.onload = () => resolve(reader.result);
    //        reader.onerror = () => reject(reader.error);
    //        reader.readAsArrayBuffer(blob);
    //    });
    //}


    //function stopRecording() {
    //    mediaRecorder?.stop();
    //    console.log('stopped rec');
    //    socket?.close(3000, 'Done');
    //}

    var connectionUrl = document.getElementById("connectionUrl");
    var connectButton = document.getElementById("connectButton");
    var stateLabel = document.getElementById("stateLabel");
    var commsLog = document.getElementById("commsLog");
    var closeButton = document.getElementById("closeButton");
    var port = document.location.port ? (":" + document.location.port) : "";

    connectionUrl.value = "wss://" + document.location.hostname + port + "@AppConfig.SpeechWsEndpoint";

    function updateState() {
        function disable() {
            closeButton.disabled = true;
        }
        function enable() {
            closeButton.disabled = false;
        }

        connectionUrl.disabled = true;
        connectButton.disabled = true;

        if (!socket) {
            disable();
        } else {
            switch (socket.readyState) {
                case WebSocket.CLOSED:
                    stateLabel.innerHTML = "Closed";
                    disable();
                    connectionUrl.disabled = false;
                    connectButton.disabled = false;
                    break;
                case WebSocket.CLOSING:
                    stateLabel.innerHTML = "Closing...";
                    disable();
                    break;
                case WebSocket.CONNECTING:
                    stateLabel.innerHTML = "Connecting...";
                    disable();
                    break;
                case WebSocket.OPEN:
                    stateLabel.innerHTML = "Open";
                    enable();
                    break;
                default:
                    stateLabel.innerHTML = "Unknown WebSocket State: " + htmlEscape(socket.readyState);
                    disable();
                    break;
            }
        }
    }

    closeButton.onclick = function () {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            alert("socket not connected");
        }
        stopRecording();
    };

    connectButton.onclick = function () {
        stateLabel.innerHTML = "Connecting";
        socket = new WebSocket(connectionUrl.value);
        startRecording();
        socket.onopen = function (event) {
            updateState();
            commsLog.innerHTML += '<tr>' +
                '<td colspan="3" class="commslog-data">Connection opened</td>' +
                '</tr>';
        };
        socket.onclose = function (event) {
            updateState();
            commsLog.innerHTML += '<tr>' +
                '<td colspan="3" class="commslog-data">Connection closed. Code: ' + htmlEscape(event.code) + '. Reason: ' + htmlEscape(event.reason) + '</td>' +
                '</tr>';
        };
        socket.onerror = updateState;
        socket.onmessage = function (event) {
            commsLog.innerHTML += '<tr>' +
                '<td class="commslog-server">Server</td>' +
                '<td class="commslog-client">Client</td>' +
                '<td class="commslog-data">' + htmlEscape(event.data) + '</td></tr>';
        };
    };

    function htmlEscape(str) {
        return str.toString()
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
</script>


